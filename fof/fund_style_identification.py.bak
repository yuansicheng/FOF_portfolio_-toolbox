#!/usr/bin/python
# -*- coding: utf-8 -*-

# @Author	:	yuansc
# @Contact	:	yuansicheng@ihep.ac.cn
# @Date		:	2022-07-12 

import os, sys, argparse, logging

import pandas as pd
import numpy as np
from abc import ABC, abstractmethod

from dateutil.parser import parse
from dateutil.relativedelta import relativedelta

import h5py
import statsmodels.api as sm
from tqdm import tqdm

import yaml

# from base_classes.fund_raw_data_svc import fund_raw_data_svc

'''
基金风格识别

基类 FundStyleIdentification
基金风格识别主要分为三个步骤
    1、基金类别筛选（_fundPrimarySelection）：按照基金类别从基金池选择，复制李老师的代码
    2、基金条件筛选（_fundOptimizeSeletion）：filter_condition中设置的条件，复制李老师的代码
    3、基金风格识别（_fundStyleIdentification）：纯虚函数，子类中实现
    *前两步操作对于股票和债券可以使用相同的代码

债券基金风格识别 BondStyleIdentification
_fundStyleIdentification函数实现了campisi模型；
setFactorDict函数定义了campisi因子配置，后期可移入配置文件；
campisi使用OLS对基金每日收益和因子做多元回归，回归结果按照一定的标准得到基金分类，判别标准后期也可移入配置文件。

股票基金风格识别，做法与债券型基金类似，但是回归时采用一元回归，将基金与每个因子分别回归后，计算R^2占比，最后按照分位点的方式确定风格。
提供三套风格方案，可在main中选择


其他：基金类别代码和债券股票基金类别的对应关系在fund_type.yaml中维护

'''

class FundStyleIdentification(ABC):
    def __init__(self, id_date,  filter_condition, rolling_window, PARAM, fund_data) -> None:
        self.id_date = id_date
        self.filter_condition = filter_condition
        self.rolling_window = rolling_window
        self.PARAM = PARAM
        self.fund_data = fund_data

        # self._fund_raw_data_svc = fund_raw_data_svc

        # for abstract methods
        # self._primary_selection = []
        # self._optimize_selection = []
        self.identification = {}

        self._fundListInit()
        self._loadFundType()

        self.setType()

    def setType(self, type_=None):
        if not type_ is None:
            self._fund_type = type_
            return
        if 'Bond' in self.__class__.__name__:
            self._fund_type = 'bond'
        if 'Stock' in self.__class__.__name__:
            self._fund_type = 'stock'


    def _fundPrimarySelection(self):
        self.fundTypeSelect()

    def _fundOptimizeSeletion(self):
        '''
        基于基金年龄、基金持仓、基金规模等，筛选基金
        '''
        self.fund_list_type_filter = self.fund_list_type
        for col, condition in self.filter_condition.items():
            # print(col, condition)
            if condition >= 0:
                self.fund_list_type_filter = self.fund_list_type_filter.loc[self.fund_list_type_filter[col] >= condition]
            if condition < 0:
                self.fund_list_type_filter = self.fund_list_type_filter.loc[self.fund_list_type_filter[col] <=(-1*condition)]
            # print(self.fund_list_type_filter.shape)
        
        self.fund_list_type_filter.reset_index(drop=True, inplace=True)

        # drop duplicate
        self.fund_list_type_filter.drop_duplicates(subset=['f_info_windcode'], keep='first', inplace=True)


    @abstractmethod
    def _fundStyleIdentification(self):
        pass
    
    def getFundIdentification(self):
        if not self.identification:
            print('Step 1: 基金初选')
            self._fundPrimarySelection()
            print('Step 2: 基金优选')
            self._fundOptimizeSeletion()
            print('Step 3: 基金风格识别')
            self._fundStyleIdentification()

        for k, v in self.identification.items():
            print(k, ': ', v)
        return self.identification

    # copy from LXW
    def _fundListInit(self):
        '''
        基于输入的fund_data，merge基金基本信息表
        
        初始化self.fund_list，数据格式如下：
            f_info_windcode  基金代码
            s_info_sector    基金类型对应编码
            fund_age         基金在id_date当日的基金年龄（单位：月）
            fund_del         基金在id_date当日停牌多久，未停牌基金置-1
            netasset_total   基金在id_date当日（或最近交易日）合计净资产（单位：元）
            f_prt_stocktotot 基金在id_date最近4个季度股票持仓占比（基于总资产）的均值（单位：%）    #最近4个季度基于季报发布日往前推算
            f_prt_bondtotot  基金在id_date最近4个季度债券持仓占比（基于总资产）的均值（单位：%）    #最近4个季度基于季报发布日往前推算
            
            f_info_issudate  基金发行日      # 不返回 备用
            f_info_isinitial 是否为初始基金  # 不返回 备用

            is_indexfund 是否指数基金
        '''
        
        ### 日期初始化
        self.fund_data['ChinaMutualFundNAV']['price_date']               = pd.to_datetime(self.fund_data['ChinaMutualFundNAV']['price_date'])
        self.fund_data['ChinaMutualFundDescription']['f_info_issuedate'] = pd.to_datetime(self.fund_data['ChinaMutualFundDescription']['f_info_issuedate'])
        self.fund_data['ChinaMutualFundDescription']['f_info_delistdate'] = pd.to_datetime(self.fund_data['ChinaMutualFundDescription']['f_info_delistdate'])
        self.fund_data['AShareCalendar']['trade_days']                   = pd.to_datetime(self.fund_data['AShareCalendar']['trade_days'])
        self.fund_data['ChinaMutualFundAssetPortfolio']['f_ann_date']    = pd.to_datetime(self.fund_data['ChinaMutualFundAssetPortfolio']['f_ann_date'])
        
        ### 基金代码、基金年龄、基金类型、是否初始基金
        fund_info = self.fund_data['ChinaMutualFundDescription'][['f_info_windcode', 'f_info_issuedate', 'f_info_isinitial', 'f_info_delistdate', 'is_indexfund']]   # 基金代码、基金发行日、是否是初始基金、退市日期、是否指数基金
        fund_sector = self.fund_data['ChinaMutualFundSector'][['f_info_windcode', 's_info_sector']]  # 基金代码、基金类型编码
        
        ### 基金净资产规模    # 数据为id_date当天或最近交易日
        fund_data_calendar = self.fund_data['AShareCalendar'].loc[self.fund_data['AShareCalendar']['s_info_exchmarket']=='SSE']
        fund_data_calendar = fund_data_calendar.loc[fund_data_calendar['trade_days'] <= parse(self.id_date)]
        latest_tradeday = max(fund_data_calendar['trade_days'])    # id_date当天或最近交易日
        
        fund_totalNV = self.fund_data['ChinaMutualFundNAV'].loc[self.fund_data['ChinaMutualFundNAV']['price_date']==latest_tradeday]
        fund_totalNV = fund_totalNV[['f_info_windcode', 'netasset_total']]
        
        
        ### 基金持仓-资产配置数据-默认计算id_date前4个季度股票、债券资产平均持仓比例
        # 取最近4个季度股票、债券持仓比例
        qtr_n = 4    # 取最近4个季度持仓比例均值     # 后续可以考虑设为输入参数
        fund_allocation = self.fund_data['ChinaMutualFundAssetPortfolio'][['s_info_windcode','f_ann_date', 'f_prt_stocktotot', 'f_prt_bondtotot']]
        fund_allocation.fillna(0, inplace=True)
        fund_allocation = fund_allocation.loc[fund_allocation['f_ann_date'] <= parse(self.id_date)]
        fund_allocation.sort_values(by=['s_info_windcode', 'f_ann_date'], ascending=False, inplace=True)
        fund_allocation = fund_allocation.reset_index(drop=True).groupby(by='s_info_windcode').head(qtr_n)
        
        # 计算最近4个季度平均股票、债券持仓比例
        fund_allocation = fund_allocation.groupby('s_info_windcode').mean()
        fund_allocation.reset_index(inplace=True)
        fund_allocation.rename(columns={'s_info_windcode':'f_info_windcode'}, inplace=True)    # 修改code列名 后续merge
        
        ### 合并基本信息数据
        fund_list = pd.merge(fund_info, fund_sector, how='left', on=['f_info_windcode'])    # merge基金
        fund_list = pd.merge(fund_list, fund_totalNV, how='left', on=['f_info_windcode'])
        fund_list = pd.merge(fund_list, fund_allocation, how='left', on=['f_info_windcode'])
        fund_list['fund_age'] = (parse(self.id_date) -  fund_list['f_info_issuedate']).dt.days/30   # 计算基金年龄(单位：月)
        fund_list['fund_del'] = (parse(self.id_date) -  fund_list['f_info_delistdate']).dt.days/30   # 计算基金停牌时间(单位：月)

        
        # 填充nan
        fund_list['fund_age'].fillna(0, inplace=True)
        fund_list['fund_del'].fillna(-1, inplace=True)
        fund_list['netasset_total'].fillna(0, inplace=True)
        
        ###选取初始基金    #默认 后续可修改
        fund_list = fund_list.loc[(fund_list['f_info_isinitial'] == 1)]
        
        #
        fund_list = fund_list[['f_info_windcode', 's_info_sector', 'fund_age', 'netasset_total', 'f_prt_stocktotot', 'f_prt_bondtotot', 'fund_del', 'is_indexfund']]
    
        self.fund_list = fund_list

    def _loadFundType(self):
        with open(self.PARAM['FUND_TYPE_YAML_FILE'], 'r', encoding='utf-8') as f:
            fund_type_yaml_data = yaml.load(f, Loader=yaml.FullLoader)
            self._fund_type_code = fund_type_yaml_data['fund_type_code']
            self._fund_type_dict = fund_type_yaml_data['fund_type_dict']

    def getFundTypeCode(self, fund_type):
        return self._fund_type_code[fund_type]

    def fundTypeSelect(self):    
        '''
        基于Wind基金分类，筛选基金类型
        * 需要日常维护
        fund_list: df 含有字段's_info_sector'(基金类型编码)   # 后续在此函数中merge基金类型编码              
        fund_type: 债券基金：'bond'
                   股票基金：'stock'
        '''
      
        fund_type_code = [self.getFundTypeCode(x) for x in self._fund_type_dict[self._fund_type]]    # 获取基金类型对应的编码        
        self.fund_list_type = self.fund_list.loc[self.fund_list['s_info_sector'].isin(fund_type_code)]    # 获取相应类型基金   
        
        self.fund_list_type.reset_index(drop=True,inplace=True)

    def getDailyYield(self, code, mode='fund'):
        if mode == 'fund':
            close_data = self.fund_data['ChinaMutualFundNAV'].query('f_info_windcode == "{}"'.format(code))
            close_data.index = close_data['price_date']
            close_data.sort_index(inplace=True)
            close_data = close_data['f_nav_adjusted']
        elif mode == 'factor':
            close_data = self.factor_raw_data[code]
        close_data = close_data.sort_index()
        # print(close_data.loc[:self.id_date].iloc[-self.rolling_window:])
        return (close_data / close_data.shift() - 1).loc[:self.id_date].iloc[-self.rolling_window:]


    def calculateFactor(self):
        # calculate factor
        self.factor_df = pd.DataFrame()
        for factor, construction in self.factor_dict.items():
            self.factor_dict[factor] = sum([self.getDailyYield(code, mode='factor') * weight for code, weight in construction.items()])
            self.factor_df[factor] = self.factor_dict[factor]
        # print(self.factor_df)

        # add constant
        self.factor_df = sm.add_constant(self.factor_df)

    def getFactorExposureAll(self, max_n=-1):
        n = 0
        self.exposure = {}
        codes = list(self.fund_list_type_filter['f_info_windcode'])
        for i in tqdm(range(len(codes))):
            code = codes[i]
            if n == max_n:
                break
            # self.exposure[code] = self.getFactorExposureOne(code)
            try:
                self.exposure[code] = self.getFactorExposureOne(code)
                n += 1
            except Exception as e:
                print('error: ', code)
                print(e.__class__.__name__, ': ', e)



class BondStyleIdentification(FundStyleIdentification):
    def __init__(self, id_date, filter_condition, rolling_window, PARAM, fund_data) -> None:
        super().__init__(id_date,  filter_condition, rolling_window, PARAM, fund_data)

        self.setFactorDict()
        self.loadFatorRawData()
        self.calculateFactor()

    def setFactorDict(self):
        # {factor_name: {code1: weight1, code2: weight2}, ...}
        self.factor_dict = {
            'LEVEL': {'CBA00601.CS': 1}, 
            'SLOPE': {'CBA00622.CS': 1, 'CBA00652.CS': -1}, 
            'CREDIT': {'CBA04201.CS': 1, 'CBA02501.CS': -1}, 
            'DEFAULT': {'CBA03801.CS': 1, 'CBA04201.CS': -1}, 
            'CONVERTIBLE': {'000832.CSI': 1}, 
            'EQUITY': {'000985.CSI': 1}, 
        }


    def getFactorExposureOne(self, fund_code):
        daily_yield = self.getDailyYield(fund_code)

        # OLS method
        results = sm.OLS(daily_yield.values, self.factor_df).fit()
        # print(results.summary())       
        return results.params, results.pvalues

    def loadFatorRawData(self):
        # load raw_data
        factor_path = os.path.join(self.PARAM['DB_LOC'], 'market_index/day')
        self.factor_raw_data = {}
        for factor_file in os.listdir(factor_path):
            factor_code = '.'.join(factor_file.split('.')[:-1])
            data = pd.read_csv(os.path.join(factor_path, factor_file))
            data.index = data['date']
            data.index = pd.to_datetime(data.index)
            self.factor_raw_data[factor_code] = data['close']


    def calParamsP75(self):
        # params dict: store all param values
        params_dict = {factor: [v[0][factor] for v in self.exposure.values()] for factor in self.factor_dict}
        # params_p75: largest 25% position
        self.params_p75 = {factor: np.percentile(v, 75) for factor, v in params_dict.items()}

    def _fundStyleIdentification(self):
        self.getFactorExposureAll(max_n=self.PARAM['max_n'])
        self.identify()

    def identify(self):
        self.calParamsP75()
        self.identification = {
            'conservative': [], 
            'balanced': [],
            'active': [],
        }

        for code, exposure in self.exposure.items():
            params, pvalues = exposure[0], exposure[1]
            # the rules
            ##############################
            # conservative
            if pvalues['LEVEL'] <= 0.01 \
                and pvalues['SLOPE'] <= 0.01 \
                and (pvalues[['CREDIT', 'DEFAULT', 'CONVERTIBLE', 'EQUITY']]>0.1).all():
                self.identification['conservative'].append(code)
            elif params['LEVEL'] >= self.params_p75['LEVEL'] \
                or params['SLOPE'] >= self.params_p75['SLOPE']:
                self.identification['conservative'].append(code)
            # active
            elif pvalues['CONVERTIBLE'] <= 0.01 \
                and pvalues['EQUITY'] <= 0.01 \
                and (pvalues[['LEVEL', 'SLOPE', 'CREDIT', 'DEFAULT']]>0.1).all():
                self.identification['active'].append(code)
            elif params['CONVERTIBLE'] >= self.params_p75['CONVERTIBLE'] \
                or params['EQUITY'] >= self.params_p75['EQUITY']:
                self.identification['active'].append(code)
            # balanced
            elif (pvalues[['LEVEL', 'SLOPE', 'CREDIT', 'DEFAULT']]<=0.05).all() \
                and (pvalues[['CONVERTIBLE', 'EQUITY']]>0.1).all():
                self.identification['balanced'].append(code)


class StockStyleIdentification(FundStyleIdentification):
    def __init__(self, id_date, filter_condition, rolling_window, PARAM, fund_data, criterion='value_growth') -> None:
        super().__init__(id_date,  filter_condition, rolling_window, PARAM, fund_data)

        self.criterion = criterion

        self.setFactorDict()
        self.loadFatorRawData()
        self.calculateFactor()  

    def _fundStyleIdentification(self):
        self.getFactorExposureAll(max_n=self.PARAM['max_n'])
        self.identify()

    def setFactorDict(self):
        # {factor_name: {code1: weight1, code2: weight2}, ...}
        

        if self.criterion == 'value_growth':
            self.factor_dict = {
                'VALUE': {'399371.SZ': 1},
                'GROWTH': {'399370.SZ': 1},
            }
        elif self.criterion == 'industry':
            self.factor_dict = {
                'FINANCIAL': {'CI005917.WI': 1},
                'CYCLICAL': {'CI005918.WI': 1},
                'CONSUMER': {'CI005919.WI': 1},
                'GROWTH': {'CI005920.WI': 1},
                'STABLE': {'CI005921.WI': 1},
            }
        elif self.criterion == 'market_size':
            self.factor_dict = {
                'LARGE': {'399314.SZ': 1},
                'MEDIUM': {'399315.SZ': 1},
                'SMALL': {'399316.SZ': 1},
            }
        else:
            raise ValueError('criterion must in (value_growth, industry, market_size')

    def loadFatorRawData(self):
        # load raw_data
        factor_path = os.path.join(self.PARAM['DB_LOC'], 'market_index/index')
        self.factor_raw_data = {}
        for factor_file in os.listdir(factor_path):
            factor_code = '.'.join(factor_file.split('.')[:-1])
            data = pd.read_csv(os.path.join(factor_path, factor_file), index_col=0)
            # data.index = data['date']
            data.index = [parse(str(date)) for date in data.index]
            self.factor_raw_data[factor_code] = data['s_dq_close']

    def getFactorExposureOne(self, fund_code):
        # print(fund_code)
        daily_yield = self.getDailyYield(fund_code)
        rsquare_standerd = {}

        # OLS method
        for factor in self.factor_dict:
            result = sm.OLS(daily_yield.values, self.factor_df[['const', factor]]).fit()
            rsquare_standerd[factor] = result.rsquared
        # standardization
        rsquare_sum = np.linalg.norm(list(rsquare_standerd.values()))
        rsquare_standerd = {k:v/rsquare_sum for k,v in rsquare_standerd.items()}
        
        return rsquare_standerd


    def calParamsP75(self):
        # params dict: store all param values
        params_dict = {factor: [v[factor] for v in self.exposure.values()] for factor in self.factor_dict}
        # params_p75: largest 25% position
        self.params_p75 = {factor: np.percentile(v, 75) for factor, v in params_dict.items()}

    def identify(self):
        self.calParamsP75()
        self.identification = {factor: [] for factor in self.factor_dict}

        # print(self.params_p75)
        for code, exposure in self.exposure.items():
            tmp = {k:v for k,v in exposure.items() if v>=self.params_p75[k]}
            if not tmp:
                continue
            factor, exposure_max = sorted(tmp.items(), key=lambda x: x[1])[0]
            # print(factor, exposure_max)
            if exposure_max >= self.params_p75[factor]:
                self.identification[factor].append(code)



    